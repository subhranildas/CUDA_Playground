#include "kernels.h"
#include "utils.h"
#include "aes.h"
#include <cstdio>
#include <cstring>

// const uint8_t key128[16] = {
//     0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
//     0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};

// const uint8_t key192[24] = {
//     0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52,
//     0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,
//     0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b};

// const uint8_t key256[32] = {
//     0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
//     0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
//     0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
//     0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};

// const uint8_t plaintext[16] = {
//     0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d,
//     0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34};

// const uint8_t expected_cipher[16] = {
//     0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb,
//     0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b, 0x32};

/* Simple host test: use GPU AES ECB encrypt for multiple blocks and verify via CPU decrypt */
int main(int argc, char **argv)
{
	(void)argc;
	(void)argv;

	const size_t blocks = 1;
	const size_t len = blocks * AES_BLOCK_SIZE;

	/* Example AES-128 key (same as tests) */
	const uint8_t key128[16] = {
		0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
		0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};

	const uint8_t plaintext[16] = {
		0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d,
		0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34};

	const uint8_t expected_cipher[16] = {
		0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb,
		0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b, 0x32};

	// uint8_t plaintext[len];
	uint8_t ciphertext[len];
	uint8_t decrypted[len];

	// for (size_t i = 0; i < len; ++i)
	// 	plaintext[i] = (uint8_t)(i & 0xFF);

	/* Call GPU encrypt helper */
	aes_error_te err = aes_encrypt_ecb_cuda(plaintext, len, ciphertext, key128,
											AES_KEY_SIZE_128);
	if (err != AES_SUCCESS)
	{
		printf("GPU encryption failed (err=%d)\n", (int)err);
		return 1;
	}

	if (memcmp(ciphertext, expected_cipher, AES_BLOCK_SIZE) == 0)
	{
		printf("GPU AES-ECB single-block encryption PASSED\n");
	}
	else
	{
		printf("GPU AES-ECB single-block encryption FAILED\n");
		return 4;
	}

	/* Decrypt on GPU and verify */
	err = aes_decrypt_ecb_cuda(ciphertext, len, decrypted, key128, AES_KEY_SIZE_128);
	if (err != AES_SUCCESS)
	{
		printf("GPU decryption failed (err=%d)\n", (int)err);
		return 2;
	}

	if (memcmp(plaintext, decrypted, len) == 0)
	{
		printf("GPU AES-ECB multi-block round-trip PASSED\n");
		return 0;
	}
	else
	{
		printf("GPU AES-ECB multi-block round-trip FAILED\n");
		return 3;
	}
}
